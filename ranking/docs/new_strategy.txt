分档现状
优质：
15: is_social=1          依赖social->social_uids，转发聚合时，插入对应的结构
14: vip or good_uid    依赖good->uids词典，转发聚合时，插入对应的结构
12: is_social=2          依赖social->social_uids，该档次在插入聚合体时被视作低质
11：电影意图、有效转发、实体词，小于该档次，每页该uid的结果最多出现一个
9  : 非黑名单且非差来源vip且是电影意图且qi档次>=3且是实体词
除了9、11，其他都需要依赖词典，由于不是微博的属性计算，这部分应该考虑不变或者把分档函数名式传过来；
13：抽象出来的档次，用于去重、图片作弊、uid去重、fake doc等检查的豁免
这个类似9档，也是人工指定，如果14,15是自动分档，那么这个类似9档，都作为一种splitN来指定；
10：选优被打成重复的召回
低质：
8：不属于优质，处理1000之后微博非优质的、转发或qi低质的被打成该档，最后的召回阶段，只召回该档次的微博； 可属性计算
7：不符合优质的任一条件则为该档； 可属性计算
6:  7档的重复召回、1000之后的重复判为该档；不可属性计算
5:  7档非重复微博，该档基本不独立使用，结合doc->rank < ac_sta.top_n_time来判定某条微博是否召回；不可属性计算
4：有两个区别较大的含义。一是选优阶段重复产生的；二是判重时导致置换产生的；处理方式topn的重复需要召回则为10，否则就删除；不可属性计算
3：未使用
2：未使用
1：删除，任何情况下一条微博要被删除，都标记该档；
0：未使用
 
优质的策略相对明确，低质的策略比较复杂：
所以现在低质分三类：
1 计算出来的低质
2 优质重复产生的低质
3 低质重复产生的低质
低质的使用主要有三类：
1 TOPN的重复召回
2 TOPN低质的召回
3 1000后的重复召回
 
基于上面的总结，自动分档计划按照下面方式进行：
分档设计：
h1    15    传函数指针 or 保持现状(传该档次但无实际计算)
h2    14    传函数指针 or 保持现状(传该档次但无实际计算)
...
hn
-------------high split(13)
m1    11
m2
...
mn
-------------low split(9)
l1    8
l2    7
...
ln    
-------------
固定档次的low
6
5
4
1
h m 是优质档次；l是低质档次；所有的低质档次都按目前7档的处理方式；在此基础上产生固定档次的low(6/5/4)
 
 
实现方面：
有些档次例如 13和9在多个函数用到，且是当全局变量直接使用，重载的话体量太大；所以要对使用这些分档的函数进行改写，通过配置来决定使用哪个值；
reranking重新实现一个版本，其他函数不重新实现，把全局变量改成传参数。
































